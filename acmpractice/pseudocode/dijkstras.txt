/*

it works because each time, i'm picking the non-visited node that's closest to A. 
Doesn't matter whether or not it's connected to the last node that I was on.
Dijkstra's algorithm is not like a snake going down the paths. It picks the optimal node and makes the desicion from there.


Say I'm on node D. node D is the closest non-visited node from A. 

If C is a neighbor of D, and while I'm on node D, and I know that

dist(D) + weight(D,C) < dist(C) ,

then I know that going from C to D has to be (currently) the shortest path to C.  ***most important step

C's path is updated this way all the time, so after each iteration I can ensure that I'm getting the current shortest path to C.

When I eventually get to the point where C is the closest non-visited node from A, by this time, I'll have the shortest path to get to C from A.

Draw diagrams, watch youtube videos to prove this to yourself. It does make sense, and it does work.

*/


Dijkstra(graph, weights, start):

	Initialize graph, start 	// d(start) = 0
	
	set = []					// set of nodes we know the shortest path to
	
	queue = graph.nodes()		// queue is all nodes
	
	
	
	while(!queue.isEmpty()):
		
		u = EXTRACT_MIN(queue)	//delete 'u' from queue
		
		set.append(u)
		
		for(v: u.neighbors):
			
			relax(u,v)
			

			
relax(u,v,w):
	
	if( dist(v) > dist(u) + weight(u,v) ):
		
		v.distance = dist(u) + weight(u,v)

		